schema {
  query: QueryRoot
  mutation: MutationRoot
}

type Publisher {
  id: String!
  walletAddress: String!
  balance: Float!
  erc721Balance: Int!
  erc1155Balance: [Nft1155Balance!]!
}

input TransferERC1155Input {
  workId: String!
  toAddress: String!
  amount: Int!
}

type ContractConnection {
  edges: [ContractEdge!]!
  nextKey: String!
  totalCount: Int
}

input SellERC721Input {
  workId: String!
  ether: Float!
}

type FrameConnection {
  edges: [FrameEdge!]!
  nextKey: String!
  totalCount: Int
}

type TokenConnection {
  edges: [TokenEdge!]!
  nextKey: String!
  totalCount: Int
}

type MutationRoot {
  registerPublisher(input: RegisterPublisherInput!): String!
  syncCsv: Boolean!
  importWork(input: ImportWorkInput!): Boolean!
  importFrame(input: ImportFrameInput!): Boolean!
  preSignUploadWork: PreSignUploadUrl!
  preSignUploadFrame: PreSignUploadUrl!
  deleteWork(id: String!): Boolean!
  registerContract(input: RegisterContractInput!): Contract!
  mintErc721(input: MintERC721Input!): Boolean!
  mintErc1155(input: MintERC1155Input!): Boolean!
  sellErc721(input: SellERC721Input!): Boolean!
  sellErc1155(input: SellERC1155Input!): Boolean!
  transferErc721(input: TransferERC721Input!): Boolean!
  transferErc1155(input: TransferERC1155Input!): Boolean!
  syncAllTokens: Boolean!
}

input RegisterContractInput {
  address: String!
  schema: Schema!
  abi: String!
}

type IsOwn {
  erc721: Boolean!
  erc1155: Boolean!
}

type Token {
  address: String!
  workId: String!
  tokenId: String!
  name: String!
  description: String!
  imageUrl: String!
  priceEth: Float
  contract: Contract!
  isOwn: Boolean!
}

input ImportWorkInput {
  isAsync: Boolean!
}

input MintERC721Input {
  workId: String!
  gsPath: String!
  useIpfs: Boolean!
  isAsync: Boolean!
}

type Frame {
  id: String!
  workId: String!
  imagePath: String!
  signedImageUrl: String!
  work: Work!
}

input TransferERC721Input {
  workId: String!
  toAddress: String!
}

type QueryRoot {
  me: Publisher!
  works(nextKey: String, limit: Int): WorkConnection!
  worksByIds(ids: [String!]!): [Work!]!
  work(id: String!): Work!
  frames(workId: String!, nextKey: String, limit: Int): FrameConnection!
  contracts(nextKey: String, limit: Int): ContractConnection!
  contractsByAddresses(addresses: [String!]!): [Contract!]!
  contract(address: String!): Contract!
  tokens(address: String!, nextKey: String, limit: Int): TokenConnection!
  mintedToken(workId: String!): MintedToken!
  isOwnNft(workId: String!): IsOwn!
}

type FrameEdge {
  node: Frame!
}

type ContractEdge {
  node: Contract!
}

input SellERC1155Input {
  workId: String!
  ether: Float!
  amount: Int!
}

type WorkConnection {
  edges: [WorkEdge!]!
  nextKey: String!
  totalCount: Int
}

type Nft1155Balance {
  tokenName: String!
  balance: Int!
}

input ImportFrameInput {
  isAsync: Boolean!
}

enum Schema {
  ERC721
  ERC1155
}

type Work {
  id: String!
  videoPath: String!
  signedVideoUrl: String!
  frames: [Frame!]!
}

enum Network {
  RINKEBY
  GOERLI
}

type MintedToken {
  erc721: Token
  erc1155: Token
}

type Contract {
  address: String!
  schema: Schema!
  network: Network!
  tokens: [Token!]!
}

input MintERC1155Input {
  workId: String!
  gsPath: String!
  amount: Int!
  useIpfs: Boolean!
  isAsync: Boolean!
}

type PreSignUploadUrl {
  url: String!
}

input RegisterPublisherInput {
  email: String!
  password: String!
  walletAddress: String!
  walletSecret: String!
}

type TokenEdge {
  node: Token!
}

type WorkEdge {
  node: Work!
}
