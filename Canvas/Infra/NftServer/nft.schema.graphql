schema {
  query: QueryRoot
  mutation: MutationRoot
}

type Thumbnail {
  id: String!
  imagePath: String!
  signedImageUrl: String!
  order: Int!
}

input CreateWorkInput {
  fileName: String!
}

type MutationRoot {
  registerUser(input: RegisterUserInput!): User!
  createWork(input: CreateWorkInput!): Boolean!
  createThumbnail(input: CreateThumbnailInput!): Boolean!
  preSignUploadWork: PreSignUploadUrl!
  preSignUploadThumbnail: PreSignUploadUrl!
  updateWorkStatus(input: UpdateWorkStatusInput!): Boolean!
  createNft(input: CreateNftInput!): Boolean!
  bindNftToWork(input: BindNftToWorkInput!): Boolean!
  deleteWork(id: String!): Boolean!
}

input CreateNftInput {
  workId: String!
  thumbnailUrl: String!
  point: Int!
  level: Int!
}

input RegisterUserInput {
  address: String!
}

type QueryRoot {
  getMe: User!
  allWorks(status: WorkStatus, nextKey: String, limit: Int): WorkConnection!
  purchasableWorks(nextKey: String, limit: Int): WorkConnection!
  purchasableWorksByIds(ids: [String!]!): [Work!]!
  work(id: String!): Work!
  ownerOfNft(workId: String!): String!
  isOwnNft(address: String!, workId: String!): Boolean!
}

type NFT {
  workId: String!
  address: String!
  tokenId: String!
  name: String!
  description: String!
  imageUrl: String!
  imagePreviewUrl: String!
  permalink: String!
  usdPrice: Float!
  ethPrice: Float!
}

type WorkConnection {
  edges: [WorkEdge!]!
  nextKey: String
  totalCount: Int
}

enum WorkStatus {
  PREPARE
  FREE
}

input BindNftToWorkInput {
  workId: String!
  contractAddress: String!
  tokenId: String!
}

type Work {
  id: String!
  videoPath: String!
  signedVideoUrl: String!
  status: WorkStatus!
  price: Int!
  thumbnails: [Thumbnail!]!
  nft: NFT
}

input CreateThumbnailInput {
  fileName: String!
}

type User {
  id: String!
  address: String!
  balance: Float!
  nftNum: Int!
}

type PreSignUploadUrl {
  url: String!
  fileName: String!
}

input UpdateWorkStatusInput {
  id: String!
  status: WorkStatus!
}

type WorkEdge {
  node: Work!
}
